#! /usr/bin/env bash

#-------------------------------------------------------------------------------
# Copyright (c) 2022.
# Все права защищены.
#
# Автор: Zeleza
# Email: mail @ zeleza точка ru
#
# Все права защищены.
#
# Продукт распространяется под лицензией Apache License 2.0
# Текст лицензии и его основные положения изложены на русском
# и английском языках, по ссылкам ниже:
#
# https://github.com/qzeleza/kotomka/blob/main/LICENCE.ru
# https://github.com/qzeleza/kotomka/blob/main/LICENCE.en
#
# Перед копированием, использованием, передачей или изменением
# любой части настоящего кода обязательным условием является
# прочтение и неукоснительное соблюдение всех, без исключения,
# статей, лицензии Apache License 2.0 по вышеуказанным ссылкам.
#-------------------------------------------------------------------------------

DEV_MANIFEST_DIR_NAME=''
ROOT_PATH_ARG="${1}"
DEV_CONFIG_FILE="${ROOT_PATH_ARG}/build.conf"
. "${DEV_CONFIG_FILE}"
#set -e

RED="\033[31m";
GREEN="\033[32m";
BLUE="\033[36m";
YELLOW="\033[33m";
BLINK_ON="\033[5m";
BLINK_OFF="\033[25m";
NOCL="\033[m";
PREF='>> '
WAITING="ЖДИТЕ"

SAVE_CURSOR="\033[s"
RESTORE_CURSOR="\033[u"
ERASE_TO_END_OF_LINE="\033[K"

CURSOR_OFF="\033[?25l"
#CURSOR_OFF_="\033[?12;25h"
CURSOR_ON="\033[?25h"


#-------------------------------------------------------------------------------
# Ширина всех линий, отображаемых на экране 3/5 от ширины экрана
#-------------------------------------------------------------------------------
cols=$(tput cols)
LENGTH=$((cols * 3 / 5))


#-------------------------------------------------------------------------------
# Относительные к корневой директории проекта пути
# к файлам источникам (файлам разработки)
#-------------------------------------------------------------------------------

# Корневой путь до папки с исходными кодами
DEV_ROOT_PATH=./code

# Имя папки в которой будут лежать исходники на C++, Cи или Bash
# Папка будет находится в папке верхнего уровня DEV_ROOT_PATH
# Полный путь будет следующим ${DEV_ROOT_PATH}/${DEV_SRC_REL_PATH}
DEV_SRC_PATH=src

# Имя папки в которой будут лежать файлы манифеста для исходников
# в которой будут размещены все файлы, которые
# необходимы в процессе сборки файла манифеста Makefile, как
# например, postinist или postrm. Это сделано намеренно, для
# удобства, чтобы была возможность писать скрипты в отдельном файле.
#
# Полный путь будет следующим
# ${DEV_ROOT_PATH}/${DEV_COMPILE_NAME}/

DEV_COMPILE_NAME=

#-------------------------------------------------------------------------------
# ВАЖНО!
# Задание пустого значения любой из папок ниже
# предотвращает ее создание
#-------------------------------------------------------------------------------

# Имя папки в которой будут лежать исходники на Bash повторяющие
# структуру директорий устройства на котором установлена entware
# Папка будет находится в папке верхнего уровня DEV_ROOT_PATH
# Полный путь будет следующим ${DEV_ROOT_PATH}/${DEV_OPT_PATH}
DEV_OPT_PATH=files/opt

# Имя папки в которой будут лежать тесты на Bash (под bats).
# Эти тесты служат для удаленного запуска на устройстве
# Папка будет находится в папке верхнего уровня DEV_ROOT_PATH
# Полный путь будет следующим ../${DEV_REMOTE_TESTS_NAME}
DEV_REMOTE_TESTS_NAME=../../tests/remote

# Имя папки в которой будут лежать собранные из исходников
# под различные архитектуры пакеты с расширением ipk.
# Папка будет находится в папке верхнего уровня
# Полный путь будет следующим ../${DEV_SRC_NAME}
DEV_IPK_NAME=../../packages


APPS_ROOT=/apps
#APP_NAME=$(pwd | sed "s/.*\\${APPS_ROOT}\/\(.*\).*$/\1/;" | cut -d'/' -f1)
APP_NAME=$PACKAGE_NAME
PACKAGES_PATH="${APPS_ROOT}/${APP_NAME}/${DEV_IPK_NAME//..\//}"

#-------------------------------------------------------------------------------
# Данные учетной записи от имени которой собираем пакет
#-------------------------------------------------------------------------------
USER=master; GROUP=staff; U_ID=5001; G_ID=5001

#-------------------------------------------------------------------------------
#  Копируем содержимое файла при этом создаем папку назначения есть ее нет
#-------------------------------------------------------------------------------
copy_file() {
	[ -d "${2}" ] || mkdir -p "${2}"
	show_line
	echo -e "${PREF}Копируем файл..."
	echo -e "${PREF}${GREEN}${1}${NOCL}"
	echo -e "${PREF}в папку ${BLUE}${2}${NOCL}"
    cp -f "${1}" "${2}"
}


#-------------------------------------------------------------------------------
#  Создаем папку если ее нет
#-------------------------------------------------------------------------------
mkdir_when_not(){
    [ -d "${1}" ] || mkdir -p "${1}"
}

#-------------------------------------------------------------------------------
# Печатаем ответ из консоли Y/N/Q
# 	 $1 - заголовок для запроса
# 	 $2 - переменная в которой возвращается результат
#-------------------------------------------------------------------------------
read_ynq() {
    header="${1}"
#	в случае, если встретиться слово с корнем "удал", то цвет заголовка - красный
	while true; do
		echo -en "${header}"
		read -r ynq
		case "${ynq}" in
			[Yy]* ) eval "${2}=y"; break; ;;
			[NnQq]* ) eval "${2}=n"; break; ;;
			     *) echo -e "Пожалуйста ответьте на вопрос 'Y' - да или 'N' - нет, Q - выход"
			;;
		esac
	done
}

#-------------------------------------------------------------------------------
# Печатаем ответ из консоли Y/N/Q
# 	 $1 - заголовок для запроса
# 	 $2 - максимальное число позиций в списке
# 	 $3 - переменная в которой возвращается результат
#-------------------------------------------------------------------------------
read_choice(){

    header="${1}";
    max_count=${2}

    while true; do
        echo -n "${header} "
        read -r choice
        case "${choice}" in
            [1-"${max_count}"] ) eval "${3}=${choice}"; break; ;;
            [Qq]* ) eval "${3}=q"; break; ;;
                 *) echo -e "Пожалуйста введите число от 1 до ${max_count} или Q для выхода."
            ;;
        esac
    done


}


#-------------------------------------------------------------------------------
#
#	 Вспомогательные функции печати в лог отладки
#
#-------------------------------------------------------------------------------


#-------------------------------------------------------------------------------
#  Печатаем заданный текст в указанной позиции курсора - направление вперед
#  $1 - Направление установки курсора '>' - вперед и '<' - назад
#  $2 - число позиции на которое передвинется текст текст
#  $3 - передаваемый тест
#-------------------------------------------------------------------------------
cursor_set(){

	[ "${3}" = "ДОСТУПНО" ] && pos=76
	[ "${3}" = "ПРОПУСКАЕМ" ] && pos=74
	[ "${3}" = "ГОТОВО" ] && pos=78
	[ "${3}" = "ЖДЕМ" ] && pos=76
	[ "${3}" = "OШИБКА" ] && pos=78
	[ "${3}" = "ЗАПУЩЕН" ] && pos=77

	act=${1}; text=${3}
	if [ "${act}" = '>' ]; then act=C; home="\033[5000D"; else act=D; home=''; fi
	echo -ne "${home}\033[${pos}${act}${4}${text}${NOCL}"

}


#-------------------------------------------------------------------------------
#  Вычисляем разницу между длинной переданной строки и
#  заданной шириной печати - LENGTH
#-------------------------------------------------------------------------------
diff_len() {

	text_=${1//>> /}
	len__="${#text_}"

	text_=${text_//\\033\[1\;31m/}
	text_=${text_//\\033\[1\;32m/}
	text_=${text_//\\033\[36m/}
	text_=${text_//\\033\[33m/}
	text_=${text_//\\033\[m/}

	len__="${#text_}"

	len__="$(echo -n "${text_}" | wc -m)"
	res__=$((LENGTH-len__))
	echo ${res__}
set +x
}


# ------------------------------------------------------------------------------------------
#	Печать текста с выравниванием по центру
# 	$1 - текст
# ------------------------------------------------------------------------------------------
center() {
	diff=$(diff_len "${1}")
  	right=$((diff/2))
  	left=$((diff - right))
  	text=$(printf "%*s%s%*s\n" "${left}" "" "${1}" "${right}" "")
  	echo -e "${text}"
}


#-------------------------------------------------------------------------------
#  Печатаем текст сообщения заданным цветом (ЗЕЛЕНЫМ) об успехе
#  исполнения некой функции, c учетом ограничения по ширине печати - LENGTH,
#  результат которой описывается в $1.
#  Используется совместно с функциями when_ok и when_bad
#
#  $1 - передаваемый текст (обязательный параметр), по умолчанию печатаем
#  		в нижнем регистре, для переключения в верхний необходимо в начале
#  		предложения поставить два символа 'U:' или 'U|' или 'U-'
#  $2 - цвет текста в виде одной из переменной текста, по умолчанию - без цвета
#  $3 - флаг указывает на наличие печати новой строки после текста
#  $4 - выводить ли надпись ЖДИТЕ: true - по умолчанию и false - не выводить
#-------------------------------------------------------------------------------
ready() {

	mess=${1}
	_len_wait_="${#WAITING}"
	wait_flag=${4:-true}

	[ -z "${mess}" ] && (echo "Отсутствует текст сообщения!"; exit 1)
	if [ -z "${2}" ]; then _color=''; else _color=${2}; fi
	if [ -z "${_color}" ]; then _end=''; else _end=${NOCL}; fi
	if [[ "${mess}" =~ U: ]] ; then
		mess=$(echo "${mess}" | sed 's/^U[|:-]//' | awk '{print toupper($0)}');
	else mess="${mess}"; fi

	echo -ne "${_color}${mess}${_end}"
	printf "\033[$((LENGTH - ${#len_wait_} - 5))G"
	[ "${wait_flag}" = true ] && printf "${YELLOW}${BLINK_ON}${WAITING}${NOCL}"
	printf "${CURSOR_OFF}"

	if [ "${3}" = true ]; then echo ''; fi

}
#-------------------------------------------------------------------------------
#  Печатаем текст сообщения заданным цветом
#  исполнения некой функции, c учетом ограничения по ширине печати - LENGTH,
#  результат которой описывается в $1.
#  Используется совместно с функциями when_ok и when_bad
#
#  $1 - передаваемый текст (обязательный параметр)
#-------------------------------------------------------------------------------
green(){
	ready "${1}" "${GREEN}" true false
}
red(){
	ready "${1}" "${RED}" true false
}
blue(){
	ready "${1}" "${BLUE}" true false
}
#-------------------------------------------------------------------------------
#  Печатаем текст сообщения заданным цветом (КРАСНЫМ) о неуспехе
#  исполнения некой функции, c учетом ограничения по ширине печати - LENGTH,
#  результат которой описывается в $1.
#  Используется совместно с функциями when_ok и when_bad
#
#  $1 - передаваемый текст (обязательный параметр)
#  $2 - цвет текста в виде одной из переменной текста, по умолчанию ${RED}
#-------------------------------------------------------------------------------
error() {
	ready "${1}" "${RED}" true
}

#-------------------------------------------------------------------------------
#  Печатаем сообщение-предупреждение заданного цвета (ГОЛУБЫМ)
#  исполнения некой функции, c учетом ограничения по ширине печати - LENGTH,
#  результат которой описывается в $1.
#  Используется совместно с функциями when_ok и when_bad
#
#  $1 - передаваемый текст
#  $2 - цвет текста в виде одной из переменной текста, по умолчанию ${BLUE}
#-------------------------------------------------------------------------------
warning() {
	ready "${1}" "${BLUE}" true
}


#-------------------------------------------------------------------------------
#   Печатаем текст сообщения если функция завершена с каким либо результатом
#	Используем совместно с функциями ready и error
#
#   $1 - передаваемый текст, по умолчанию - ГОТОВО
#   $2 - цвет текста в виде одной из переменной текста, по умолчанию ${GREEN}
#	$3 - моргать или нет (нет - по умолчанию)
#-------------------------------------------------------------------------------
show_result() {
#set -x
	blink=${3:-no}
	[ -z "${1}" ] && text='OK' || text=${1}
	[ -z "${2}" ] && color="${BLUE}" || color=${2}
#	[ "${3}" = yes ] && color="${color}${BLINK_ON}" || color=${2}
	text=$(echo "${text}" | awk '{print toupper($0)}')
#	set -x
	len_text=${#text}
	offset=$((LENGTH - len_text - 1))
	cursor_set '>' "${offset}" "${text}" "${color}"
#	set +x
	printf "${CURSOR_ON}"
	echo ''
}


#-------------------------------------------------------------------------------
#   Печатаем текст сообщения если функция завершена УСПЕШНО!
#	Используем совместно с функциями ready и error
#
#   $1 - передаваемый текст, по умолчанию - ГОТОВО
#   $2 - цвет текста в виде одной из переменной текста, по умолчанию ${GREEN}
#-------------------------------------------------------------------------------
when_ok() {
	[ -z "${1}" ] && text='ГОТОВО' || text=${1}
#	set -x
#	if [ -z "${1}" ] ; then
#		text="ГОТОВО"
#		text_len="${#text}"
#		offset=$((LENGTH - text_len))
#	else
#		text="${1}"
#		text_len="${#text}"
#		offset=$((LENGTH - text_len - 3))
#	fi
#set +x

#	printf "\033[${offset}G"
	show_result "${text}" "${GREEN}"
}


#-------------------------------------------------------------------------------
#   Печатаем текст сообщения если функция завершена С ОШИБКОЙ!
#	Используем совместно с функциями ready и error
#
#   $1 - передаваемый текст, по умолчанию - ГОТОВО
#   $2 - цвет текста в виде одной из переменной текста, по умолчанию ${GREEN}
#-------------------------------------------------------------------------------
when_bad() {
	[ -z "${1}" ] && text='OШИБКА' || text=${1}
#	text_len="${#text}"
#	offset=$((LENGTH - text_len))
#	printf "\033[${offset}G"
	show_result "${text}" "${RED}"
}


#-------------------------------------------------------------------------------
#   Печатаем текст сообщения если функция завершена С ОШИБКОЙ!
#	Используем совместно с функциями ready и error
#
#   $1 - передаваемый текст, по умолчанию - ГОТОВО
#   $2 - цвет текста в виде одной из переменной текста, по умолчанию ${GREEN}
#-------------------------------------------------------------------------------
when_not_bad() {
	show_result "${1}" "${BLUE}"
}
#
#
##-------------------------------------------------------------------------------
##   Печатаем текст сообщения если функция завершена С ОШИБКОЙ!
##	Используем совместно с функциями ready и error
##
##   $1 - передаваемый текст, по умолчанию - ГОТОВО
##   $2 - цвет текста в виде одной из переменной текста, по умолчанию ${GREEN}
##-------------------------------------------------------------------------------
#when_wait() {
#	text=${1}
#	wait_text=${2:-ЖДИТЕ}
#	_len_wait=${#wait_text}
##	printf "%s" "${text}"
#	# move cursor to the right column
#	printf "\033[$((LENGTH - ${#_len_wait} - 2))G"
#	printf "${YELLOW}${BLINK_ON}${wait_text}${NOCL}"
#	printf "${CURSOR_OFF}\n"
#
##	show_result "${1}" "${BLUE}" yes
#}


#-------------------------------------------------------------------------------
# Печатаем строку из 100 знаков равно
#	$1 - символ который печатаем (по умолчанию '-')
#	$2 - число пробелов спереди  строки (по умолчанию '0')
#	$3 - длинна строки (по умолчанию '$LENGTH' символов )
#
#-------------------------------------------------------------------------------
print_line_sim(){

	len=$((LENGTH))
	sim=${1:--}; nspaces=${2:-0}; len=${3:-$len}
	diff=$((len - nspaces))
	printf "%${nspaces}s"
	printf "%$((len - nspaces))s\n" | tr ' ' "${sim}"
}

#-------------------------------------------------------------------------------
# Печатаем строку из 100  знаков равно
#-------------------------------------------------------------------------------
show_line(){
  print_line_sim "=" 0
}


#-------------------------------------------------------------------------------
# Получаем необходимую информацию о версии пакета
#-------------------------------------------------------------------------------
get_version_part(){

	value=${1}
	make_file="${ROOT_PATH_ARG}/${DEV_ROOT_PATH//./}/Makefile"

	if [ "${value}" = PACKAGE_VERSION ]; then cat < "${make_file}" | sed -n "s/PKG_VERSION:=\(.*\)/\1/p"; fi
	if [ "${value}" = PACKAGE_STAGE ]; 	 then cat < "${make_file}" | sed -n "s/PKG_RELEASE:=\([a-zA-Z]\{3,\}\).*/\1/p"; fi
	if [ "${value}" = PACKAGE_RELEASE ]; then cat < "${make_file}" | sed -n "s/PKG_RELEASE:=.*\([0-9]\{1,3\}\)/\1/p"; fi

}


#-------------------------------------------------------------------------------
# Получаем значение из скрытого файла конфигурации
#-------------------------------------------------------------------------------
get_config_value(){
  cat < "${DEV_CONFIG_FILE}" | grep -E "^${1}=" | cut -d'=' -f2
}

#-------------------------------------------------------------------------------
# Получаем имя приложения из названия корневой папки
#-------------------------------------------------------------------------------
#APP_NAME=$(echo "${BASEDIR}" | sed "s/.*\\${APPS_ROOT}\/\(.*\).*$/\1/;" | cut -d'/' -f1)

#-------------------------------------------------------------------------------
# Получаем имя пакета для сборки
#-------------------------------------------------------------------------------
get_full_package_version(){

	package_version=$(get_version_part PACKAGE_VERSION)
	package_stage=$(get_version_part PACKAGE_STAGE)
	package_release=$(get_version_part PACKAGE_RELEASE)

	if [ -n "${package_stage}" ] ; then stg="-${package_stage}"; else stg=""; fi
	if [ -n "${package_release}" ] ; then rel="-${package_release}"; else rel=""; fi
	echo "${package_version}${stg}${rel}"
}


#-------------------------------------------------------------------------------
# Получаем имя пакета ipk файла для сборки в контейнере
#-------------------------------------------------------------------------------
get_ipk_package_name(){
	echo "${APP_NAME}_$(get_full_package_version)_${ARCH_BUILD}.ipk"
}

#-------------------------------------------------------------------------------
# Получаем полный путь до пакета сборки в контейнере
#-------------------------------------------------------------------------------
get_ipk_package_file(){
    echo "${APPS_ROOT}/entware/bin/targets/${ARCH_BUILD}/generic-glibc/packages/$(get_ipk_package_name)"
}

#-------------------------------------------------------------------------------
# Осуществляем вход по ssh с определенными по умолчанию параметрами
# ConnectTimeout 			- Время ожидания чтобы "достучаться"
# StrictHostKeyChecking 	- В случае первого входа - сразу согласится с входом, без запроса
# PasswordAuthentication 	- Не запрашивать пароль при входе, требуется для проверки соединения.
#-------------------------------------------------------------------------------
run_ssh(){
#set -x
	dev=${2}; port=${1}; cmd=${3};
	ssh -o ConnectTimeout=2 -o StrictHostKeyChecking=no -p "${port}" "root@${dev}" "${cmd}"
}


#-------------------------------------------------------------------------------
# Осуществляем проверку на доступность IP или доменного имени
#	$1 - ip устройства
#	$2 - порт устройства
#	Возвращает yes - в случае, если устройство доступно
#			   no  - в случае, если устройство НЕ доступно
#-------------------------------------------------------------------------------
is_device_alive(){

	dev=${1}; port=${2}
	ssh -o ConnectTimeout=2 \
		-o StrictHostKeyChecking=no \
		-o PasswordAuthentication=no \
		-p "${port}" "root@${dev}" 'exit 0' 2>&1 | grep -q 'Connection timed out' && echo no || echo yes
}


#-------------------------------------------------------------------------------
# Получаем путь до ключа
#-------------------------------------------------------------------------------
get_key_file(){
	key_name=id_rsa
	key_path=$([ "$(whoami)" = root ] && echo '/root' || echo "${HOME}")
	key_file_pub="${key_path}/.ssh/${key_name}.pub"
	key_file_prv="${key_path}/.ssh/${key_name}"
	[ -f "${key_file_pub}" ] || ssh-keygen -t rsa -N "" -f "${key_file_prv}" &>/dev/null
	echo "${key_file_pub}"
}


#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Производим удаление и установку пакета
#-------------------------------------------------------------------------------
run_reinstalation_on_router(){

	dev_ip=${1}; dev_port=${2}

	ready "${PREF}Производим удаление пакета с устройства"
	run_ssh "${dev_port}" "${dev_ip}" 'opkg remove '"${APP_NAME}" &>/dev/null && when_ok || when_bad

	ready "${PREF}Производим установку пакета на устройство" "" true false
	print_line_sim "-" 0
	cmd='[ -d /opt/packages ] || mkdir /opt/packages; opkg install /opt/packages/'"$(get_ipk_package_name)"
	run_ssh "${dev_port}" "${dev_ip}" "${cmd}" #&>/dev/null && when_ok || when_bad
	show_line
}


#-------------------------------------------------------------------------------
# Получаем путь до ключа
#-------------------------------------------------------------------------------
get_key_file(){
	key_name=id_rsa
	key_path=$([ "$(whoami)" = root ] && echo '/root/.' || echo "${HOME}/.")
	key_file_pub="${key_path}ssh/${key_name}.pub"
	key_file_prv="${key_path}ssh/${key_name}"
	[ -f "${key_file_pub}" ] || ssh-keygen -t rsa -N "" -f "${key_file_prv}" &>/dev/null
	echo "${key_file_pub}"
}


#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Копируем публичный ключ на роутер
#-------------------------------------------------------------------------------
copy_ssh_keys_to_router(){
	dev_ip=${1}; dev_port=${2}

	# если ключи отсутствуют на NAS
	ready "${PREF}Копируем ключи на роутер ${dev_ip} порт ${dev_port}..."
	run_ssh "${dev_port}" "${dev_ip}" "echo \"$(cat "$(get_key_file)")\" >> /opt/root/.ssh/authorized_keys" && when_ok || when_bad
	show_line
}


#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Производим копирование собранного пакета на роутер
#-------------------------------------------------------------------------------
copy_app_to_router(){

	dev_ip=${1}; dev_port=${2}
#	show_line
#	создаем папку на устройстве для хранения упакованного пакета
	run_ssh "${dev_port}" "${dev_ip}" '[ -d /opt/packages ] || mkdir -p /opt/packages'
	app_tar_name=$(get_ipk_package_name)
	ipk_file=$(get_ipk_package_file)

#	удаляем предыдущий файл этой же версии пакета, если он там был и перемещаем его из контейнера на устройство

	ready "${PREF}Копируем пакет на устройство..."

	if ! [ -f "${PACKAGES_PATH}/${app_tar_name}" ]; then
		if ! [ -f "${ipk_file}" ]; then
			error "Файл ${ipk_file}"
			error "не найден в целевом целевом контейнере."
			exit 1
		else
			cp "${ipk_file}" "${PACKAGES_PATH}/" || \
				error "Произошла ошибка при копировании файла"
				error "${ipk_file}"
				exit 1
		fi
	fi
	{
		echo -n ''
		run_ssh "${dev_port}" "${dev_ip}" 'rm -f '"/opt/packages/${app_tar_name}" &> /dev/null
		scp -P "${dev_port}" "${PACKAGES_PATH}/${app_tar_name}" "root@${dev_ip}:/opt/packages/${app_tar_name}" &> /dev/null
	}  && when_ok || when_bad

}


#-------------------------------------------------------------------------------
# Экранируем символы '/' в строке для передачи в sed
#-------------------------------------------------------------------------------
escape()(echo "${1}" | sed 's|\/|\\/|g')


#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Получаем архитектуру текущего устройства
#-------------------------------------------------------------------------------
get_device_arch(){

	dev_ip=${1}; dev_port=${2}
	cmd_get_arch="cat /opt/etc/opkg.conf | sed -n 's/^arch.\([a-zA-Z]\{1,\}[0-9]\{0,2\}-[0-9]\{1,2\}\.[0-9]\{0,2\}\).*$/\1/p;' | head -1"
	run_ssh "${dev_port}" "${dev_ip}" "${cmd_get_arch}"
}

#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Запускаем тесты на роутере из контейнера
#-------------------------------------------------------------------------------
run_tests(){
    cd "${APPS_ROOT}/${APP_NAME}"/${DEV_REMOTE_TESTS_NAME//..\//} || exit 1
    ./tests.run
}

#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Запрашиваем разрешение на запуск тестов на роутере из контейнера
#-------------------------------------------------------------------------------
ask_run_tests(){
    answer=''; read_ynq "${PREF}Запустить тесты прямо сейчас [Y/N/Q]? " answer
    [ "${answer}" = y ] && run_tests
}

#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
# Вычисляем время между двумя временами в секундах
# и выводим время в виде ЧЧ:MM:CC
#-------------------------------------------------------------------------------
time_diff(){
    one_time=${1}
    two_time=${2}

    diff_sec=$((two_time - one_time))
    dd=$((diff_sec/86400))
    hh=$((diff_sec / 3600))
    mm=$((diff_sec / 60))
    ss=$((diff_sec % 60))

    if [ "${dd}" = 0 ]; then DD=''; else DD="${dd} дн. "; fi
    if [ "${dd}" = 0 ] && [ "${hh}" = 0 ] ; then HH=''; else HH=" ${hh} ч."; fi
    if [ "${dd}" = 0 ] && [ "${hh}" = 0 ] && [ "${mm}" = 0 ] ; then MM=''; else MM=" ${mm} мин."; fi

    echo "${DD}${HH}${MM} ${ss} сек."
}

#-------------------------------------------------------------------------------
# ИСПОЛНЯЕМ ВНУТРИ КОНТЕЙНЕРА !!!
#
# 	Копируем пакет на роутер и производим его установку
#
# 	$1 - в случае значения ask - выводим вопрос о проведении тестов,
#	   		 при иных значениях - тесты пропускаем
#
#-------------------------------------------------------------------------------
copy_and_install_package(){
#set -x
    tests_ask=${1:-no}

    for dev in ${ROUTER_LIST} ; do
#    	получаем адрес и порт (по умолчанию - 222)
    	dev_ip=$(echo "${dev}" | cut -d':' -f1 )
    	dev_port=$(echo "${dev}" | cut -d':' -f2)
    	[ "${dev_port}" = "${dev_ip}" ] && dev_port=222

		ready "${PREF}Устройство по адресу ${GREEN}${dev_ip}:${dev_port}${NOCL}..."
		# проверяем на доступность ip роутера
		if [ "$(is_device_alive "${dev_ip}" "${dev_port}")" = yes ]; then

			when_ok "ДОСТУПНО"
			# 	Проверяем есть ли ключ на роутере
			docker_key=$(cat < "$(get_key_file)")
			run_ssh "${dev_port}" "${dev_ip}" 'cat /opt/root/.ssh/authorized_keys' | grep -q "${docker_key}" || {
					show_line
					copy_ssh_keys_to_router "${dev_ip}" "${dev_port}"
			}

	#    	текущая архитектура на устройстве
			dev_arch=$(get_device_arch "${dev_ip}" "${dev_port}")
	#    	текущая архитектура в контейнере (просто название без версии )
			container_arch=$(echo "${ARCH_BUILD}" | sed -n 's|^\([a-zA-Z]\{4,\}\)[0-9]\{0,2\}\(-[0-9]\{1,2\}.[0-9]\{1,2\}\).*|\1|p')

			if [ "${ARCH_BUILD}" = "${dev_arch}" ]; then
				# копируем собранный пакет на роутер
				copy_app_to_router "${dev_ip}" "${dev_port}"
	#				запускаем установку пакета
				run_reinstalation_on_router "${dev_ip}" "${dev_port}"

				# Запускаем тесты
				case "${tests_ask}" in
					YES|Yes|yes|y ) run_tests ;;
					ASK|Ask|ask|a )
						show_line
						answer=''; read_ynq "Запустить исполнение тестов на устройстве? " answer
						if [ "${answer}" = y ]; then run_tests; else show_line; fi
						;;
					* ) ;;

				esac
			else
				echo -ne "${PREF}Устройство имеет архитектуру ${BLUE}${dev_arch}${NOCL}"
				when_bad "ПРОПУСКАЕМ"
				show_line
			fi

		else
			when_bad "НЕДОСТУПНО"
			show_line
		fi

	done

}
